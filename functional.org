#+AUTHOR: Andrea Crotti (@andreacrotti)
#+TITLE: Functional Programming, Christmas edition
#+OPTIONS: num:nil toc:nil ^:nil tex:t reveal_progress:t reveal_control:t reveal_overview:t
#+REVEAL_TRANS: none
#+REVEAL_SPEED: fast
#+REVEAL_HLEVEL: 1
#+TOC: listings

* Overview

#+BEGIN_NOTES
Welcome all and thanks for coming.
Today we are going to talk about functional programming, (so if you are in the wrong room please run now).
We'll first see a bit of history, give an overview of probably the most iconic functional programming language,
and finally get to the juicy part, how do we actually do it in Python and why.

I have a lot of material so sorry in advance if I might go a bit too fast, all the material will be fully
availabe and I'll share everything with you as soon as the talk is done.
#+END_NOTES

#+ATTR_REVEAL: :frag (appear)
 
  * Why functional programming matters
  * A bit of history
  * Brief introduction to Haskell
  * Functional patterns in Python/Haskell

* Why
  :PROPERTIES:
  :reveal_background: ./images/cat_liying.gif
  :reveal_background_size: 800px
  :END:

** Concurrency

** Abstraction

** Immutability

** OOP failure

 [[./images/oop_rip.jpg]]

#+begin_quote
 Object-oriented programming is both anti-modular and
 anti-parallel by its very nature, and hence unsuitable for a modern CS
 curriculum.

 Robert Harper (professor at Carniage Mellon University)

 #+end_quote


** Functional languages

- Haskell
- Lisp
- Clojure
- Erlang
- Elixir
- Scala
- Elm
  
* History
  :PROPERTIES:
  :reveal_background: ./images/cat_bed.gif
  :reveal_background_size: 800px
  :END:


** First there was lambda calculus

#+BEGIN_QUOTE
*Turing complete, universal* model of computation that can be used to simulate any single-taped Turing machine.
#+END_QUOTE

First introduced in *1930* by Alonzo Church, and based on:

- function abstraction
- variable binding and substitution

** Lambda calculus primer

Sample function definitions:
#+ATTR_REVEAL: :frag (appear)
  * $\lambda x. x$
  * $\lambda x y. x$
  * $\lambda x. \lambda y. x$

** Sample reduction
#+ATTR_REVEAL: :frag (appear)
  * Assuming these definitions:
  * True: $\lambda x.\lambda y. x$
  * False: $\lambda x.\lambda y. y$
  * And: $\lambda p. \lambda q. p q p$
  * Let's prove that *True And False == False*:
  * $(\lambda p. \lambda q. p q p) (\lambda x.\lambda y. x) (\lambda x.\lambda y. y)$
  * $\beta \rightarrow (\lambda q. (\lambda x. \lambda y. x) q (\lambda x. \lambda y. x)) (\lambda x.\lambda y. y)$
  * $\beta \rightarrow (\lambda x. \lambda y. x) (\lambda x.\lambda y. y) (\lambda x.\lambda y. x)$
  * $\beta \rightarrow (\lambda x. \lambda y. y)$
  * *BINGO*

** Noone doing it


* What?

#+BEGIN_NOTES

#+END_NOTES

Programming paradigm based on *lambda calculus* (Alonzo Church)

- /functions/ are *first class* citizens
  - higher-order functions
  - partial application
  - currying

- Functions are *pure*
  - immutable data: *no state*
  - encapsulated side effects

- lazy sequences

** What if
   :PROPERTIES:
   :reveal_background: ./images/what_if_functional.jpg
   :reveal_background_size: 800px
   :END:

* What's in for me

- easier concurrency
- better composability
- easier to write tests
- more generic abstractions

* Haskell (1990)

#+BEGIN_NOTES
The original intention was to talk about Python but in reality
my first real encounter with FP was with Haskell and that's probably
the main reason why I got interested in it.

Haskell is a relatively old language (same age as Python) but it has
been for most of its history a niche research language, that people
used to write papers with.

It's probably until now the most "complete" and pure functional programming
language out there, and in some ways it's just incredibly beautiful.

This joke here refers to the fact that while there is so much interest in
Haskell not as many people use it in production, but in any case
it's still probably the best language to really learn functional programming.
#+END_NOTES

  - pure
  - lazy
  - pattern matching
  - algebraic data types
  - type inference

[[./images/haskell.png]]

* What you can't do

 - Assignments
 - Mutable data structures
 - While/For Loops
 - Have control Over Order of Execution
 - Side Effects

** Really?
   :PROPERTIES:
   :reveal_background: ./images/wtf.gif
   :END:

* Four pillars

#+BEGIN_NOTES
Now we are going to see more in detail four concepts from functional programming,
and exploring them in Python and Haskell, comparing the two together.

The first pillar is function and function composition, so what functions actually are,
what are their propreties and how do we compose them.
The second is immutability, which is simply the idea of trying to never mutate your
data in place, but always create new objects for every mutation.

Streaming refers to the ability to work on infinite infinite sequences, and finally
purity refers to the absence of side effects.
#+END_NOTES

#+ATTR_REVEAL: :frag (appear)

  * Function composition (toolz/stdlib)
  * Immutability (toolz)
  * Streaming (itertools/toolz)
  * Purity?
  * Types (mypy/voluptuous?)
  * Pattern matching ?

# TODO remove libraries from here if already mentioning them above
Libraries used:
#+ATTR_REVEAL: :frag (appear)
  * itertools
  * functools
  * toolz
  * fn.py
  * mypy

* What's a function, really

** Mathematical definition

#+BEGIN_QUOTE
A function is a relation between a set of inputs and a set of permissible outputs
with the property that each input is related to exactly one output. 
#+END_QUOTE

[[./images/function.png]]

** Def and Lambda

#+BEGIN_SRC python
  def adder(a, b):
      return a + b

  adder_lambda = lambda a, b: a + b

  adder(1, 2) # -> 3
  adder_lambda(1, 2) # -> 3

  type(adder) == type(adder_lambda) == function # -> True

#+END_SRC

** Class?

#+ATTR_REVEAL: :frag (appear)
  * Callable class
   
    #+BEGIN_SRC python
      class Adder:
          def __call__(self, a, b):
              return a + b

      my_adder = Adder()
      type(my_adder) # Adder
      my_adder(1, 2) # -> 3
    #+END_SRC

  * Generic callable interface
    
    #+BEGIN_SRC python
      callable(adder)   # -> true
      callable(my_adder) # -> true
    #+END_SRC

** Other functions?

#+ATTR_REVEAL: :frag (appear)
  * Let's define a method and call it:
    #+BEGIN_SRC python
      class Santa:
          def give_gift(self, kid, gift):
              print("Good boy {}, here is your {}".format(kid, gift))
    
      my_santa = Santa()
      my_santa.give_gift('boy', 'toy') # -> Good boy boy, here is your toy
    #+END_SRC

  * What is actually give_gift?
    #+BEGIN_SRC python
      type(Santa.give_gift) # -> function
    #+END_SRC

  * So we can just do this instead:
    #+BEGIN_SRC python
      my_santa = Santa()
      Santa.give_gift(my_santa, 'boy', 'toy') # -> Good boy boy, here is your toy
    #+END_SRC


* Toolz

Toolz provides a suite of functions which have the following functional virtues:

*Composable*: They interoperate due to their use of core data structures.
*Pure*: They don’t change their inputs or rely on external state.
*Lazy*: They don’t run until absolutely necessary, allowing them to support large streaming data sets.

** Toolz capabilities

 - *Dicttoolz*: immutable dictionaries functionality
 - *Functoolz*: extend functools
 - *Itertoolz*: extend itertools

* Immutability
   :PROPERTIES:
   :reveal_background: ./images/cat_boxing.gif
   :END:

** The mutable way:

#+BEGIN_SRC python
  def enrich_dict_mutable(dic):
      for key in dic:
          if key % 2 == 0:
              dic[key] = 'bar'

      keys_below_zero = [x for x in dic if x < 0]
      for neg in keys_below_zero:
          del dic[neg]

      return dic
#+END_SRC

** Go immutable


* Function composition
** Partial application

   *Haskell*:

#+BEGIN_SRC haskell
  my_sum:: Num a => -> a -> a -> a
  my_sum a b = a + b
  add_three = my_sum 3
  
  add_three 2 == 5
#+END_SRC

   *Python*:

#+BEGIN_SRC python
  from toolz.functoolz import partial

  def my_sum(a, b):
      return a + b

  add_three = partial(my_sum, 3)
#+END_SRC

** Currying

   *Haskell*:
#+BEGIN_SRC haskell
  my_sum:: Num a => -> a -> a -> a
  my_sum a b = a + b

  Prelude> :t my_sum 1
  my_sum 1 :: Num a => a -> a

  (my_sum 1) 2 == (my_sum 1 2)
#+END_SRC

   *Python*:

#+BEGIN_SRC python
  from toolz.functoolz import curry

  def my_sum(a, b):
      return a + b

  my_sum(a)(b) == my_sum(a, b)
#+END_SRC

** Composition

 *Haskell*:

#+BEGIN_SRC haskell
  import Data.Char (toUpper)

  get_first:: [a] -> a
  get_first lis = lis !! 0

  upper_first_letter:: [Char] -> Char
  upper_first_letter = toUpper . get_first

#+END_SRC

 *Python*:

#+BEGIN_SRC python
  from toolz.functoolz import compose
  from toolz.curried import get


  upcase_first_letter = compose(
      get(0), # lambda l: l[0]
      lambda c: c.upper(),
  )

  upcase_first_letter('hello') == 'hello'[0].upper() == 'H'
#+END_SRC

** Pipes!

Who gets a gift for Christmas??

#+BEGIN_SRC 
    people = [
        {'name': 'Bob', 'age': 10, 'well_behaved': True},
        {'name': 'Rick', 'age': 10, 'well_behaved': False},
        {'name': 'John', 'age': 20, 'well_behaved': True},
    ]

#+END_SRC

*** Classic loopy

#+BEGIN_SRC python
  def get_gifts_classic(people):
      getting_gifts = []
      for person in people:
          if person['age'] < 18 and person['well_behaved']:
              getting_gifts.append(person['name'])

      return getting_gifts

#+END_SRC

*** Toolz pipes

#+BEGIN_SRC python
  def get_gifts(people):
      # ``pipe(data, f, g, h)`` is equivalent to ``h(g(f(data)))`
      return pipe(people,
          filter(lambda v: v['age'] < 18 and v['well_behaved']),
          mapcat(get(['name'])),
          list)
#+END_SRC

*** Clojure/Elixir

#+BEGIN_SRC clojure

  (-> "hello"
      )
#+END_SRC

#+BEGIN_SRC elixir
  String.reverse(String.capitalize("philip"))
#+END_SRC


* Streaming
** To infinity and beyond

*** Infinite set of even numbers

   *Haskell*:
   
#+BEGIN_SRC haskell
  [x | x <- [0..], x `mod` 2 == 0]
#+END_SRC

   *Python*:

#+BEGIN_SRC python
  def evens():
      ev = 0
      while True:
          yield ev
          ev += 2


  gen_ev = evens()
  for n in range(10):
      print(next(gen_ev))
#+END_SRC

    *Smarter Python*:
    
#+BEGIN_SRC python
  from itertools import count
  from toolz.itertoolz import take

  for ev in take(10, count(0, 2)):
      print(ev)
#+END_SRC


* Types
** Mypy

 #+BEGIN_SRC python
   def typed_addition(a: int, b: int) -> int:
       return a + b
 #+END_SRC


* Side effects

** Pure computation?


[[./images/haskell.png]]

** Monads to the rescue

** Call me Maybe

[[./images/maybe.png]]

#+BEGIN_SRC haskell
  data Maybe a = Nothing | Just a
#+END_SRC

** Monads and Python

#+BEGIN_SRC python
  from pymonad.Maybe import *
  from pymonad.List import *

  # 'neg' knows nothing about functor types...
  def neg(x):
      return -x

  # ... but that doesn't stop us from using it anyway.
  neg * Just(9)                 # returns Just(-9)
  neg * Nothing                 # returns Nothing
  neg * List(1, 2, 3, 4)        # returns List(-1, -2, -3, -4)
#+END_SRC

* Testing

** Quickcheck

#+BEGIN_SRC haskell
  import Test.QuickCheck

  prop_revapp :: [Int] -> [Int] -> Bool
  prop_revapp xs ys = reverse (xs++ys) == reverse xs ++ reverse ys

  main = quickCheck prop_revapp
#+END_SRC

** Hypothesis

* Putting it all together

* Quotes

** 10 100

#+BEGIN_QUOTE
"It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures." —Alan Perlis
#+END_QUOTE
   
** Describing

#+BEGIN_QUOTE
Functional programming is like describing your problem to a mathematician.
Imperative programming is like giving instructions to an idiot. - Arcus #scheme
#+END_QUOTE

** Cloud

#+BEGIN_QUOTE
  OOP cannot save us from the Cloud Monster anymore. - Ju Gonçalves
#+END_QUOTE

** Functions

#+BEGIN_QUOTE

Functional Programming is so called because a program consists entirely of functions.

- John Hughes, Why Functional Programming Matters

#+END_QUOTE

** Python FP

#+BEGIN_QUOTE
using Python for Functional Programming it's like looking at a beautiful view through a dirty window - 

#+END_QUOTE

* Conclusion


* Resources

- [[http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf][Why functional programming matters]]
- [[https://www.youtube.com/watch?v=-6BsiVyC1kM][the value of values]]
- [[https://www.youtube.com/watch?v=-6BsiVyC1kM][Clojure transducers]]
- [[http://learnyouahaskell.com/][Learn You a Haskell for Great Good]]
- [[https://github.com/pytoolz/toolz][toolz]]
- [[http://mypy-lang.org/][mypy lang]]
- [[http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html][functors, applicatives, and monads in pictures]]
- [[https://wiki.haskell.org/Tutorials/Programming_Haskell/String_IO][Haskell String IO]]
- [[https://github.com/tobgu/pyrsistent][pyrsistent, persistent data structures in Python]]
- [[http://coconut-lang.org/][Coconut lang]]
- [[https://github.com/kachayev/fn.py][fn.py library]]
- [[https://github.com/Suor/funcy][funcy Python library]]
- [[http://people.eecs.berkeley.edu/~gongliang13/lambda/][lambda calculus interpreter]]
- [[https://medium.com/@FunctionalWorks/the-rise-of-frontend-functional-languages-c073bd8ea8ed#.yualxlz77][rise of functional programming on the frontend]]
- [[https://www.wiki.ed.ac.uk/display/SAPMW/2015/02/23/The+Rise+Of+Functional+Programming+In+Industry][rise of functional programming in the industry]]
- [[https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/][fighting spam with Haskell]]

 # Local Variables:
 # after-save-hook: (org-reveal-export-to-html)
 # End:
