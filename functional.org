#+AUTHOR: Andrea Crotti
#+TITLE: Functional Christmas Programming
#+OPTIONS: num:nil ^:nil tex:t toc:nil reveal_progress:t reveal_control:t reveal_overview:t
#+REVEAL_TRANS: fade
#+REVEAL_SPEED: fast
#+EMAIL: andrea.crotti.0@gmail.com
#+TOC: listings

* Abstract

This talk will be a journey in the world of functional programming, starting from its origin to the current days.

After an introduction and a bit of theory we will talk about how to do functional programming in Python and what are the advantages.

* What?

#+BEGIN_NOTES

#+END_NOTES

Programming paradigm based on *lambda calculus* (Alonzo Church)

- /functions/ are *first class* citizens
  - higher-order functions
  - partial application
  - currying

- Functions are *pure*
  - immutable data: *no state*
  - encapsulated side effects

- lazy sequences

* Why should I bother

- *concurrent* world
- OOP is doesn't compose well
- threading is hard and painful

* What's in for me

- easier concurrency
- better composability
- easier to write tests
- more generic abstractions

* Haskell (1990)

#+BEGIN_NOTES
The original intention was to talk about Python but in reality
my first real encounter with FP was with Haskell and that's probably
the main reason why I got interested in it.

Haskell is a relatively old language (same age as Python) but it has
been for most of its history a niche research language, that people
used to write papers with.

It's probably until now the most "complete" and pure functional programming
language out there, and in some ways it's just incredibly beautiful.

This joke here refers to the fact that while there is so much interest in
Haskell not as many people use it in production, but in any case
it's still probably the best language to really learn functional programming.
#+END_NOTES

  - pure
  - lazy
  - pattern matching
  - algebraic data types
  - type inference

[[./images/haskell.png]]


* Love it or hate it

* What you can't do

 - Assignments
 - Mutable data structures
 - While/For Loops
 - Control Over Order of Execution
 - Side Effects

[[./images/wtf.gif]]

* Python functional Christmas

** Imperative

#+BEGIN_SRC python

#+END_SRC

** OOP 

** Functional

* Map reduce & co

** No more looping

* Functools

* Itertools

* Toolz

Toolz provides a suite of functions which have the following functional virtues:

*Composable*: They interoperate due to their use of core data structures.
*Pure*: They don’t change their inputs or rely on external state.
*Lazy*: They don’t run until absolutely necessary, allowing them to support large streaming data sets.

** Toolz capabilities

 - *Dicttoolz*: immutable dictionaries functionality
 - *Functoolz*: extend functools
 - *Itertoolz*: extend itertools

** Immutable dictionaries

Problem:

Given 

*** The mutable way:

#+BEGIN_SRC python
  def enrich_dict_mutable(dic):
      for key in dic:
          if key % 2 == 0:
              dic[key] = 'bar'

      keys_below_zero = [x for x in dic if x < 0]
      for neg in keys_below_zero:
          del dic[neg]

      return dic
#+END_SRC

** Partial application

   *Haskell*:

#+BEGIN_SRC haskell
  my_sum:: Num a => -> a -> a -> a
  my_sum a b = a + b
  add_three = my_sum 3
  
  add_three 2 == 5
#+END_SRC

   *Python*:

#+BEGIN_SRC python
  from toolz.functoolz import partial

  def my_sum(a, b):
      return a + b

  add_three = partial(my_sum, 3)
#+END_SRC

** Currying

   *Haskell*:
#+BEGIN_SRC haskell
  my_sum:: Num a => -> a -> a -> a
  my_sum a b = a + b

  Prelude> :t my_sum 1
  my_sum 1 :: Num a => a -> a

  (my_sum 1) 2 == (my_sum 1 2)
#+END_SRC

   *Python*:

#+BEGIN_SRC python
  from toolz.functoolz import curry

  def my_sum(a, b):
      return a + b

  my_sum(a)(b) == my_sum(a, b)
#+END_SRC

** Composition

 *Haskell*:

#+BEGIN_SRC haskell
  import Data.Char (toUpper)

  get_first:: [a] -> a
  get_first lis = lis !! 0

  upper_first_letter:: [Char] -> Char
  upper_first_letter = toUpper . get_first

#+END_SRC

 *Python*:

#+BEGIN_SRC python
  from toolz.functoolz import compose
  from toolz.curried import get


  upcase_first_letter = compose(
      get(0), # lambda l: l[0]
      lambda c: c.upper(),
  )

  upcase_first_letter('hello') == 'hello'[0].upper() == 'H'
#+END_SRC

** Pipes!

Who gets a gift for Christmas??

#+BEGIN_SRC 
    people = [
        {'name': 'Bob', 'age': 10, 'well_behaved': True},
        {'name': 'Rick', 'age': 10, 'well_behaved': False},
        {'name': 'John', 'age': 20, 'well_behaved': True},
    ]

#+END_SRC

*** Classic loopy

#+BEGIN_SRC python
  def get_gifts_classic(people):
      getting_gifts = []
      for person in people:
          if person['age'] < 18 and person['well_behaved']:
              getting_gifts.append(person['name'])

      return getting_gifts

#+END_SRC

*** Toolz pipes

#+BEGIN_SRC python
  def get_gifts(people):
      # ``pipe(data, f, g, h)`` is equivalent to ``h(g(f(data)))`
      return pipe(people,
          filter(lambda v: v['age'] < 18 and v['well_behaved']),
          mapcat(get(['name'])),
          list)
#+END_SRC

** Iterables

* Mypy

#+BEGIN_SRC python
  def typed_addition(a: int, b: int) -> int:
      return a + b
#+END_SRC

* Side effects

** Pure computation?

[[./images/haskell.png]]

** Monads to the rescue

** 

* Testing

** Quickcheck

** Hypothesis

* Putting it all together

* Python lacking

- TCO (Tail Call Optimization)
- Persistent data structures
- Types?

* Resources

- [[http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf][Why functional programming matters]]
- [[https://www.youtube.com/watch?v=-6BsiVyC1kM][the value of values]]
- [[https://www.youtube.com/watch?v=-6BsiVyC1kM][Clojure transducers]]
- [[http://learnyouahaskell.com/][Learn You a Haskell for Great Good]]
