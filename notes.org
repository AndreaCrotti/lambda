#+AUTHOR: Andrea Crotti
#+TITLE: Functional Programming
#+OPTIONS: num:nil ^:nil tex:t
#+REVEAL_TRANS: fade
#+REVEAL_SPEED: fast
#+EMAIL: andrea.crotti.0@gmail.com

* 
  :PROPERTIES:
  :reveal_background: ./images/should_learn.jpg
  :reveal_background_trans: slide
  :reveal_background_size: 800px
  :END:

* What if
  :PROPERTIES:
  :reveal_background: ./images/what_if_functional.jpg
  :reveal_background_trans: slide
  :reveal_background_size: 800px
  :END:

* What?

#+BEGIN_NOTES
What are we going to talk about
#+END_NOTES

  - Full model of computation (Alonzo Church)
  - /functions/ are *first class* citizens
    - higher-order functions
    - partial application
    - currying

  - Functions are pure
    - immutable data: *no state*
    - encapsulated side effects

  - lazy sequences

** List of constraints

 - No Assignments.
 - No Varying Your Variables. (Immutable)
 - No While/For Loops.
 - No Control Over Order of Execution.
 - No Side Effects.
 - No Mutating or changing state.

** What really

#+begin_quote

   Functional Programming is so called because a program consists entirely of functions.

   - John Hughes, Why Functional Programming Matters

#+end_quote

* What is a function

\begin{equation}
f(x) = 2 x + 1
\end{equation}

- output depends *only* on the input
- no side effect

\begin{equation}
f(4) = 9
\end{equation}

- *referential integrity*

** Function domains

[[./images/domain.png]]

* OOP is dead

#+begin_quote
"Object-oriented programming is eliminated entirely from the
introductory curriculum, because it is both anti-modular and
anti-parallel by its very nature, and hence unsuitable for a modern CS
curriculum."

- Robert Harper (professor at Carniage Mellon University)
#+end_quote

* Simple example

** OOP

#+begin_src python

  class Transformer(object):
      def __init__(self, collection):
          self.data = collection

      def func(self, collection):
          return filter(lambda x: x % 2 ==0, collection)

      def transform(self):
          self.data = self.func(self.data)

  tr = Transformer(range(10))
  tr.transform()
  tr.data

#+end_src

** FP

#+begin_src python
  def evens(collection):
      return filter(lambda x: x % 2 ==0, collection)

  def transform(func, collection):
      return func(collection)

  transform(evens, range(10))
#+end_src

* Languages

  - Haskell
  - Clojure
  - Scala
  - F#
  - Erlang
  - Elixir
  - Elm

* Why?

  - concurrency (multicore)
  - threading sucks
  - it's the next big paradigm shift (and it's already happening)
  - write *better* code

* Code


#+begin_src python
  def foo(x):
    if x>0:
      return x+1
    else:
      return x-1

  foo(1)
#+end_src

#+RESULTS:
: 2

* Lambda calculus

  - full *model* of computation
  - currying
  - higher order function
  - map/reduce/whatever
  - Church numerals introduction

* Side effects and immutability

  - what is a side effect
  - why is it bad
  - how to encapsulate them properly
  - demo about refactoring using

* Design principles

  - OOP issues
  - designing without classes
  - composition over inheritance
  - parallel with all the states in the universe and how to test with that

* Python and FP issues

  - (almost) everything is mutable
  - no tail call optimization

  - what is a function in Python
  - decorators short intro
  - methods/classmethods/functions and behaviour

* Toolz

  - Show some nice examples such as:
    toolz.itemmap(reversed, dic)

* Generators and higher order functions

  - infinite streams
  - relationship between streams and pure functions

* Testing

  - testing pure functions
  - show the refactor example from the crappy solution to testing with hypothesis

* Resources

  - Okasaki for persistent data structures
  - All Rich Hickey talks

* Haskell

  -

* Quotes
  - "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures." â€”Alan Perlis

# Local Variables:
# after-save-hook: (org-reveal-export-to-html)
# End:
