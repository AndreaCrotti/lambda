#+AUTHOR: Andrea Crotti
#+TITLE: Functional Programming
#+OPTIONS: num:nil ^:nil tex:t toc:nil reveal_progress:t reveal_control:t reveal_overview:t
#+REVEAL_TRANS: fade
#+REVEAL_SPEED: fast
#+EMAIL: andrea.crotti.0@gmail.com
#+TOC: listings

* 
  :PROPERTIES:
  :reveal_background: ./images/should_learn.jpg
  :reveal_background_trans: slide
  :reveal_background_size: 800px
  :END:

#+BEGIN_NOTES
In the last few years there has been a lot of hype about functional programming.

Many languages like Clojure or Scala are growing extremely fast in popularity and many big companies
are moving more and more to functional programming.

And this affects anyone, if you look at some job postings it's almost certain that they will contain
a functional programming exposure or knowledge (even the Python engineer job post here at Skimlinks does).
#+END_NOTES


* What?

#+BEGIN_NOTES
So let's start to talk about what is functional programming which will help understanding why
it's becoming so important in the software world.
Functional programming is a full model of computation based on lambda calculus.
This means that it's a model that can represent anything that is computable, in the same
way as a turing maching can (or any language that is usually defined Turing Complete).

We might see in more detail an example about Lambda calculus later on if we have time.

In functional programming are the building block and always considered first class citizens.
You also need to be able to define higher order functions, and perform partial appliaction and currying.

Functions also need to be pure, which means that there is no external state that affects them,
and the data has to be immutable.
Any side effect should be then in fact encapsulated.

Another very common building block of FP are lazy sequences, which work extremely well with
immutability.
#+END_NOTES

  - Full model of computation based on *lambda calculus* (Alonzo Church)

  - /functions/ are *first class* citizens
    - higher-order functions
    - partial application
    - currying

  - Functions are pure
    - immutable data: *no state*
    - encapsulated side effects

  - lazy sequences

** List of constraints

#+BEGIN_NOTES
There is another way to define functional programming, which is in term of the constraints that are added.
There is a very interesting talk from Bob Martin where he points out that every paradigm shift brings
a new set of constraints, which overall make our lives a lot better.

As OOP took away from use the GOTO statement, these are the things that you shall not do in functional
programming.
#+END_NOTES

You shall *NOT* have:

 - Assignments
 - Mutable data structures
 - While/For Loops
 - Control Over Order of Execution
 - Side Effects

[[./images/wtf.gif]]

** What simplified

#+begin_quote

   Functional Programming is so called because a program consists entirely of functions.

   - John Hughes, Why Functional Programming Matters

#+end_quote

* Why?

#+BEGIN_NOTES
So after we briefly introduced what is functional programming we are going
to say why it is becoming so important and prevalent.

Functional programming is even older than OOP and for many years it was
considered a niche environment, but probably the biggest change
that caused everyone to jump on the FP train is the multicore revolution.

When even your watch has multiple cores being able to write safe concurrent
code becomes very important, and the traditional ways (using threads, locks,
and so on and so forth) are just terrible and will ruin your life.

On top of that programming has become more and more complex, and OOP
programs just don't compose well.

The code you will write if you learn FP will be also definitively better,
more testable and more reusable then the one you are used to write.

#+END_NOTES

# [[./images/why.gif]]

  - threading sucks
  - OOP does not compose
  - write *better* code
  - it's the next big paradigm shift (and it's already happening)

# TODO: show an example about how hard is to write concurrent code?

** OOP is dead


#+BEGIN_NOTES
About OOP this is a quote from a professor of the Carniage Mellon
University which expresses this view quite clearly.

OOP is still the taught in all universisties but luckily some
of them are starting to realise that it's not what we need anymore.
#+END_NOTES

 [[./images/oop_rip.jpg]]

 #+begin_quote
 Object-oriented programming is both anti-modular and
 anti-parallel by its very nature, and hence unsuitable for a modern CS
 curriculum.

  Robert Harper (professor at Carniage Mellon University)

 #+end_quote

* What is a function

#+BEGIN_NOTES
So since we said that FP is based on functions, let's have a look again at what
functions are in their mathematical terms.

From this example the function f takes an input x and return a value
that depends on it.

The output of f depends only on the input we pass in, and this function
has no side effects.

The other important property of a function is referential transparency,
which means that for a function defined as such you can always replace
the function call by its result, and the end result of the program
will still be exactly the same.
#+END_NOTES

\begin{equation}
f(x) = 2 x + 1
\end{equation}

- output depends *only* on the input
- no side effect -> *pure*

\begin{equation}
f(4) = 9
\end{equation}

- *referential transparency*:
  a function call can be always replaced by its result

** Domains

#+BEGIN_NOTES

Another important thing to consider is that every pure function
is that it has a domain and a codomain, so it always transforms
values of type X to values of type Y.

Not all FP programming languages are statically typed but types
are always present anyway and you should always keep them in mind.

#+END_NOTES

[[./images/domain.png]]

* Haskell


#+BEGIN_NOTES
The original intention was to talk about Python but in reality
my first real encounter with FP was with Haskell and that's probably
the main reason why I got interested in it.

Haskell is a relatively old language (same age as Python) but it has
been for most of its history a niche research language, that people
used to write papers with.

It's probably until now the most "complete" and pure functional programming
language out there, and in some ways it's just incredibly beautiful.
#+END_NOTES

  - First version in 1990
  - pure
  - lazy
  - pattern matching
  - algebraic data types
  - type inference

[[./images/haskell.png]]

** Fibonacci

#+BEGIN_NOTES
Let's just see a couple of examples of haskell code.
First of all we can define a fibonacci function that computes
the nth fibonacci number, and does it recursively.

This first definition is incredibly simple and is just
the same as the mathematical definition.
First we define the type above, which means that fib is a function
that takes an int and returns another int.

And then we define top-down the output of the function itself,
first with two specific values (using pattern matching) and then
in the generic case.
#+END_NOTES


#+begin_src haskell
  fib :: Int -> Int
  fib 0 = 0
  fib 1 = 1
  fib n = fib (n-1) + fib (n-2)
#+end_src


#+BEGIN_NOTES
The second function is even more interesting since it condense in two lines
the essence of all the beauty.

Now instead of defining fibs recursively straight away we instead define
the whole fibonacci sequence, recursively as an infinite list of ints!
The way this works is that we use the : to create a list and concatenate
0 and 1 to the result of zipWith (+) fibs (tail fibs).
#+END_NOTES

Or better:

#+begin_src haskell
  -- zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
  fibs:: [Int]
  fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

  -- get the 10th fibonacci number from
  fib :: Int -> Int
  fib n = fibs !! n
#+end_src

Which in Python is roughly:

#+begin_src python
  first_fibs = [0, 1, 2, 3, 5]

  fibs = [0, 1] + map(sum, zip(first_fibs, first_fibs[1:]))
  # Out[5]: [0, 1, 1, 2, 3, 5, 8]
#+end_src

#+RESULTS:

** Quicksort

#+begin_src haskell
  quicksort :: (Ord a) => [a] -> [a]
  quicksort [] = []
  quicksort (x:xs) =
      let smallerSorted = quicksort [a | a <- xs, a <= x]
          biggerSorted = quicksort [a | a <- xs, a > x]

      in  smallerSorted ++ [x] ++ biggerSorted
#+end_src

* Other languages

  - Clojure
  - Scala
  - F#
  - Erlang
  - Elixir
  - Elm

* Simple example

** OOP

#+begin_src python

  class Transformer(object):
      def __init__(self, collection):
          self.data = collection

      def func(self, collection):
          return filter(lambda x: x % 2 ==0, collection)

      def transform(self):
          self.data = self.func(self.data)

  tr = Transformer(range(10))
  tr.transform()
  tr.data

#+end_src

** FP

#+begin_src python
  def evens(collection):
      return filter(lambda x: x % 2 ==0, collection)

  def transform(func, collection):
      return func(collection)

  transform(evens, range(10))
#+end_src

* Side effects and immutability

  - what is a side effect
  - why is it bad
  - how to encapsulate them properly
  - demo about refactoring using

* Immutability

  [[./images/too_many_objects.png]]

** Persistent data structures 1/2

#+begin_src haskell

  xs = [0, 1, 2]
  ys = [3, 4, 5]

#+end_src

[[./images/persistent1.png]]

** Persistent data structures 2/2

#+begin_src haskell
  zs = xs ++ ys
#+end_src

[[./images/persistent2.png]]

* Python and FP

  - [ ] immutability
  - [ ] TCO (Tail Call Optimization)
  - [ ] side effects encapsulation
  - [ ] type system
  - [X] functions first class citizens

* Python and functions

** Methods, classmethods, staticmethods, functions, lambda??

[[./images/confused.gif]]

* Are we screwed?

** Itertools

   - standard library module for infinite streams
   - *use it*

#+begin_src python

#+end_src

** Toolz

   - library with many nice functional programming functions

#+begin_src python
  import toolz

  bills = {
      "Alice": 0,
      "Bob": 1,
  }
#+end_src

BAD:

#+begin_src python
    def change_inline(bills):
        for key, val in bills.items():
            bills[key] = val + 1
#+end_src

GOOD:

#+begin_src python
  def change_immutable(dic):
      func = lambda val: val + 1
      return toolz.valmap(func, dic)
#+end_src

** Generators and higher order functions

   - infinite streams
   - relationship between streams and pure functions

** Pypersistent?

* Testing

  - testing pure functions
  - show the refactor example from the crappy solution to testing with hypothesis

** Refactor journey

#+begin_src python
  import subprocess, MySQLdb

  def long_crappy_function():
      ## launching a shell command
      ls_cmd = 'ls'
      p = subprocess.Popen(ls_cmd,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
      ## filtering the output of a shell command
      out, err = p.communicate()
      res = []
      for line in out:
          if 'to-match' in line:
              res.append(line)

      ## updating the results to database
      dbc = MySQLdb.connect(host='host', user='user',
                            passwd='passwd', port='port')
      cursor = dbc.cursor(MySQLdb.cursors.DictCursor)

      for r in res:
         cursor.execute('INSERT INTO table VALUES (%s)' % r)

#+end_src

** Extract database update


#+begin_src python

  def update_to_database(res):
      ## updating the results to database
      dbc = MySQLdb.connect(host='host', user='user', passwd='passwd', port='port')
      cursor = dbc.cursor(MySQLdb.cursors.DictCursor)

      for r in res:
         cursor.execute('INSERT INTO table VALUES (%s)' % r)
 #+end_src

** Extract 'ls' execution


#+begin_src python

  def run_ls():
      ## launching a shell command
      ls_cmd = 'ls'
      p = subprocess.Popen(ls_cmd,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
      ## filtering the output of a shell command
      out, err = p.communicate()

      return out

#+end_src

** Extract filter output

#+begin_src python


  def filter_output(out):
      res = []
      for line in out:
          if 'to-match' in line:
              res.append(line)

      return res

#+end_src

Or even better:

#+begin_src python

  def filter_output(out):
      return filter(lambda l: 'to-match' in l, out)

#+end_src


** And finally


#+begin_src python
  def write_filtered_ls_to_db():
      """Do a bit of everything
      """
      out = run_ls()
      res = filter_output(out)
      update_to_database(res)
#+end_src

* FP and testing

Testing becomes much *easier*

#+begin_src python

  def filter_output(out):
      return filter(lambda l: 'to-match' in l, out)

  def test_filter_output():
      lines = ['x1: to-match', 'x2', 'x3: to-match..']
      desired = ['x1: to-match', 'x3: to-match..']
      assert filter_output(lines) == desired

#+end_src

** Property based testing

- originally from Haskell

* Resources

  - Okasaki for persistent data structures
  - All Rich Hickey talks
  - Why functional programming matters


* Conclusions

1. Lock Free Concurrency.
2. Brevity. (Modular Code)
3. Lazy Evaluation.
4. Composability.
5. Parallelism.
5. Improved ways of Testing.
6. Referential Transparency.
7 Lesser Bugs.

* Quotes
  - "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures." —Alan Perlis
  - Functional programming is like describing your problem to a mathematician.
  - Imperative programming is like giving instructions to an idiot.
  - OOP cannot save us from the Cloud Monster anymore.
  - using Python for FP it's like looking at a beautiful view through a dirty window

* Extra material

** Lambda calculus primer
   
   Formal system for expressing computation based on
   - function abstraction
   - variable binding and substitution

Church numerals (s = suc):

\begin{equation}
0 \equiv \lambda sz. z
\end{equation}

\begin{equation}
1 \equiv \lambda sz. s(z)
\end{equation}

\begin{equation}
2 \equiv \lambda sz. s(s(z))
\end{equation}

*Successor*

\begin{equation}
S \equiv \lambda wyx. y(wyx)
\end{equation}
\begin{equation}
S(0) \equiv (\lambda wyx.y(wyx))(\lambda sz.z) = 
\end{equation}

\begin{equation}
\lambda yx.y ((\lambda sz. z) yx) = \lambda yx. y(x) \equiv 1
\end{equation}

# Local Variables:
# after-save-hook: (org-reveal-export-to-html)
# End:
