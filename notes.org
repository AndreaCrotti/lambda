#+AUTHOR: Andrea Crotti
#+TITLE: Functional Programming
#+OPTIONS: num:nil ^:nil tex:t toc:nil
#+REVEAL_TRANS: fade
#+REVEAL_SPEED: fast
#+EMAIL: andrea.crotti.0@gmail.com
#+TOC: listings

* 
  :PROPERTIES:
  :reveal_background: ./images/should_learn.jpg
  :reveal_background_trans: slide
  :reveal_background_size: 800px
  :END:

* 
  :PROPERTIES:
  :reveal_background: ./images/what_if_functional.jpg
  :reveal_background_trans: slide
  :reveal_background_size: 800px
  :END:

* What?

#+BEGIN_NOTES
What are we going to talk about
#+END_NOTES

  - Full model of computation (Alonzo Church)
    based on *lambda calculus*

  - /functions/ are *first class* citizens
    - higher-order functions
    - partial application
    - currying

  - Functions are pure
    - immutable data: *no state*
    - encapsulated side effects

  - lazy sequences

** List of constraints

 - No Assignments.
 - No Varying Your Variables. (Immutable)
 - No While/For Loops.
 - No Control Over Order of Execution.
 - No Side Effects.
 - No Mutating or changing state.

** What really

#+begin_quote

   Functional Programming is so called because a program consists entirely of functions.

   - John Hughes, Why Functional Programming Matters

#+end_quote

* What is a function

\begin{equation}
f(x) = 2 x + 1
\end{equation}

- output depends *only* on the input
- no side effect

\begin{equation}
f(4) = 9
\end{equation}

- *referential integrity*

** Function domains

[[./images/domain.png]]

* OOP is dead

[[./images/oop_rip.jpg]]

#+begin_quote
Object-oriented programming is both anti-modular and
anti-parallel by its very nature, and hence unsuitable for a modern CS
curriculum.

 Robert Harper (professor at Carniage Mellon University)

#+end_quote

* Simple example

** OOP

#+begin_src python

  class Transformer(object):
      def __init__(self, collection):
          self.data = collection

      def func(self, collection):
          return filter(lambda x: x % 2 ==0, collection)

      def transform(self):
          self.data = self.func(self.data)

  tr = Transformer(range(10))
  tr.transform()
  tr.data

#+end_src

** FP

#+begin_src python
  def evens(collection):
      return filter(lambda x: x % 2 ==0, collection)

  def transform(func, collection):
      return func(collection)

  transform(evens, range(10))
#+end_src

* Languages

  - Haskell
  - Clojure
  - Scala
  - F#
  - Erlang
  - Elixir
  - Elm

* Why?

  - concurrency (multicore)
  - threading sucks
  - it's the next big paradigm shift (and it's already happening)
  - write *better* code

* Haskell

  - pure
  - lazy
  - pattern matching
  - algebraic data types
  - type inference

[[./images/haskell.png]]

** Fibonacci

#+begin_src haskell
  fib :: Int -> Int
  fib 0 = 0
  fib 1 = 1
  fib n = fib (n-1) + fib (n-2)
#+end_src

Or better:

#+begin_src haskell
  fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
#+end_src

#+RESULTS:

** Quicksort

#+begin_src haskell
  quicksort :: (Ord a) => [a] -> [a]
  quicksort [] = []
  quicksort (x:xs) =
      let smallerSorted = quicksort [a | a <- xs, a <= x]
          biggerSorted = quicksort [a | a <- xs, a > x]

      in  smallerSorted ++ [x] ++ biggerSorted
#+end_src

* Lambda calculus

  - full *model* of computation
  - currying
  - higher order function
  - map/reduce/whatever
  - Church numerals introduction

* Side effects and immutability

  - what is a side effect
  - why is it bad
  - how to encapsulate them properly
  - demo about refactoring using

* Immutability

  [[./images/too_many_objects.png]]

** Persistent data structures 1/2

#+begin_src haskell

  xs = [0, 1, 2]
  ys = [3, 4, 5]

#+end_src

[[./images/persistent1.png]]

** Persistent data structures 2/2

#+begin_src haskell
  zs = xs ++ ys
#+end_src

[[./images/persistent2.png]]

* Python and FP

  - [ ] immutability
  - [ ] TCO (Tail Call Optimization)
  - [ ] side effects encapsulation
  - [ ] type system
  - [X] functions first class citizens

* Python and functions

** Methods, classmethods, staticmethods, functions, lambda??

[[./images/confused.gif]]

* Are we screwed?

** Itertools

   - standard library module for infinite streams
   - *use it*

#+begin_src python

#+end_src

** Toolz

   - library with many nice functional programming functions

#+begin_src python
  import toolz

  bills = {
      "Alice": 0,
      "Bob": 1,
  }
#+end_src

BAD:

#+begin_src python
    def change_inline(bills):
        for key, val in bills.items():
            bills[key] = val + 1
#+end_src

GOOD:

#+begin_src python
  def change_immutable(dic):
      func = lambda val: val + 1
      return toolz.valmap(func, dic)
#+end_src

** Generators and higher order functions

   - infinite streams
   - relationship between streams and pure functions

** Pypersistent?

* Testing

  - testing pure functions
  - show the refactor example from the crappy solution to testing with hypothesis

** Refactor journey

#+begin_src python
  import subprocess, MySQLdb

  def long_crappy_function():
      ## launching a shell command
      ls_cmd = 'ls'
      p = subprocess.Popen(ls_cmd,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
      ## filtering the output of a shell command
      out, err = p.communicate()
      res = []
      for line in out:
          if 'to-match' in line:
              res.append(line)

      ## updating the results to database
      dbc = MySQLdb.connect(host='host', user='user',
                            passwd='passwd', port='port')
      cursor = dbc.cursor(MySQLdb.cursors.DictCursor)

      for r in res:
         cursor.execute('INSERT INTO table VALUES (%s)' % r)

#+end_src

** Extract database update


#+begin_src python

  def update_to_database(res):
      ## updating the results to database
      dbc = MySQLdb.connect(host='host', user='user', passwd='passwd', port='port')
      cursor = dbc.cursor(MySQLdb.cursors.DictCursor)

      for r in res:
         cursor.execute('INSERT INTO table VALUES (%s)' % r)
 #+end_src

** Extract 'ls' execution


#+begin_src python

  def run_ls():
      ## launching a shell command
      ls_cmd = 'ls'
      p = subprocess.Popen(ls_cmd,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
      ## filtering the output of a shell command
      out, err = p.communicate()

      return out

#+end_src

** Extract filter output

#+begin_src python


  def filter_output(out):
      res = []
      for line in out:
          if 'to-match' in line:
              res.append(line)

      return res

#+end_src

Or even better:

#+begin_src python

  def filter_output(out):
      return filter(lambda l: 'to-match' in l, out)

#+end_src


** And finally


#+begin_src python
  def write_filtered_ls_to_db():
      """Do a bit of everything
      """
      out = run_ls()
      res = filter_output(out)
      update_to_database(res)
#+end_src

* FP and testing

Testing becomes much *easier*

#+begin_src python

  def filter_output(out):
      return filter(lambda l: 'to-match' in l, out)

  def test_filter_output():
      lines = ['x1: to-match', 'x2', 'x3: to-match..']
      desired = ['x1: to-match', 'x3: to-match..']
      assert filter_output(lines) == desired

#+end_src

** Property based testing

- originally from Haskell

* Resources

  - Okasaki for persistent data structures
  - All Rich Hickey talks


* Conclusions

1. Lock Free Concurrency.
2. Brevity. (Modular Code)
3. Lazy Evaluation.
4. Composability.
5. Parallelism.
5. Improved ways of Testing.
6. Referential Transparency.
7 Lesser Bugs.

* Quotes
  - "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures." â€”Alan Perlis
  - Functional programming is like describing your problem to a mathematician.
  - Imperative programming is like giving instructions to an idiot.
  - using Python for FP it's like looking at a beautiful view through a dirty window

* Extra material

** Lambda calculus primer
   
   Formal system for expressing computation based on
   - function abstraction
   - variable binding and substitution

Church numerals (s = suc):

\begin{equation}
0 \equiv \lambda sz. z
\end{equation}

\begin{equation}
1 \equiv \lambda sz. s(z)
\end{equation}

\begin{equation}
2 \equiv \lambda sz. s(s(z))
\end{equation}

*Successor*

\begin{equation}
S \equiv \lambda wyx. y(wyx)
\end{equation}
\begin{equation}
S(0) \equiv (\lambda wyx.y(wyx))(\lambda sz.z) = 
\end{equation}

\begin{equation}
\lambda yx.y ((\lambda sz. z) yx) = \lambda yx. y(x) \equiv 1
\end{equation}

# Local Variables:
# after-save-hook: (org-reveal-export-to-html)
# End:
