#+AUTHOR: Andrea Crotti
#+TITLE: Functional Programming
#+OPTIONS: num:nil ^:nil tex:t
#+REVEAL_TRANS: fade
#+REVEAL_SPEED: fast
#+EMAIL: andrea.crotti.0@gmail.com

* 
  :PROPERTIES:
  :reveal_background: ./images/should_learn.jpg
  :reveal_background_trans: slide
  :reveal_background_size: 800px
  :END:

* What if
  :PROPERTIES:
  :reveal_background: ./images/what_if_functional.jpg
  :reveal_background_trans: slide
  :reveal_background_size: 800px
  :END:

* What?

#+BEGIN_NOTES
What are we going to talk about
#+END_NOTES

  - Full model of computation (Alonzo Church)
  - /functions/ are *first class* citizens
    - higher-order functions
    - partial application
    - currying

  - Functions are pure
    - immutable data: *no state*
    - encapsulated side effects

  - lazy sequences

** List of constraints

 - No Assignments.
 - No Varying Your Variables. (Immutable)
 - No While/For Loops.
 - No Control Over Order of Execution.
 - No Side Effects.
 - No Mutating or changing state.

** What really

#+begin_quote

   Functional Programming is so called because a program consists entirely of functions.

   - John Hughes, Why Functional Programming Matters

#+end_quote

* What is a function

\begin{equation}
f(x) = 2 x + 1
\end{equation}

- output depends *only* on the input
- no side effect

\begin{equation}
f(4) = 9
\end{equation}

- *referential integrity*

** Function domains

[[./images/domain.png]]

* OOP is dead

#+begin_quote
"Object-oriented programming is eliminated entirely from the
introductory curriculum, because it is both anti-modular and
anti-parallel by its very nature, and hence unsuitable for a modern CS
curriculum."

- Robert Harper (professor at Carniage Mellon University)
#+end_quote

* Simple example

** OOP

#+begin_src python

  class Transformer(object):
      def __init__(self, collection):
          self.data = collection

      def func(self, collection):
          return filter(lambda x: x % 2 ==0, collection)

      def transform(self):
          self.data = self.func(self.data)

  tr = Transformer(range(10))
  tr.transform()
  tr.data

#+end_src

** FP

#+begin_src python
  def evens(collection):
      return filter(lambda x: x % 2 ==0, collection)

  def transform(func, collection):
      return func(collection)

  transform(evens, range(10))
#+end_src

* Languages

  - Haskell
  - Clojure
  - Scala
  - F#
  - Erlang
  - Elixir
  - Elm

* Why?

  - concurrency (multicore)
  - threading sucks
  - it's the next big paradigm shift (and it's already happening)
  - write *better* code

* Lambda calculus

  - full *model* of computation
  - currying
  - higher order function
  - map/reduce/whatever
  - Church numerals introduction

* Side effects and immutability

  - what is a side effect
  - why is it bad
  - how to encapsulate them properly
  - demo about refactoring using

* Immutability
  
  [[./images/too_many_objects.png]]

** Persistent data structures 1/2

#+begin_src haskell

  xs = [0, 1, 2]
  ys = [3, 4, 5]

#+end_src

[[./images/persistent1.png]]

** Persistent data structures 2/2

#+begin_src haskell
  zs = xs ++ ys
#+end_src

[[./images/persistent2.png]]

* Python and FP

  - (almost) everything is mutable
  - no tail call optimization

  - what is a function in Python
  - decorators short intro
  - methods/classmethods/functions and behaviour

* Toolz

  - Show some nice examples such as:
    toolz.itemmap(reversed, dic)

* Generators and higher order functions

  - infinite streams
  - relationship between streams and pure functions

* Testing

  - testing pure functions
  - show the refactor example from the crappy solution to testing with hypothesis

** Refactor journey

#+begin_src python
  import subprocess, MySQLdb

  def long_crappy_function():
      ## launching a shell command
      ls_cmd = 'ls'
      p = subprocess.Popen(ls_cmd,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
      ## filtering the output of a shell command
      out, err = p.communicate()
      res = []
      for line in out:
          if 'to-match' in line:
              res.append(line)

      ## updating the results to database
      dbc = MySQLdb.connect(host='host', user='user',
                            passwd='passwd', port='port')
      cursor = dbc.cursor(MySQLdb.cursors.DictCursor)

      for r in res:
         cursor.execute('INSERT INTO table VALUES (%s)' % r)

#+end_src

** Extract database update


#+begin_src python

  def update_to_database(res):
      ## updating the results to database
      dbc = MySQLdb.connect(host='host', user='user', passwd='passwd', port='port')
      cursor = dbc.cursor(MySQLdb.cursors.DictCursor)

      for r in res:
         cursor.execute('INSERT INTO table VALUES (%s)' % r)
 #+end_src

** Extract 'ls' execution


#+begin_src python

  def run_ls():
      ## launching a shell command
      ls_cmd = 'ls'
      p = subprocess.Popen(ls_cmd,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
      ## filtering the output of a shell command
      out, err = p.communicate()

      return out

#+end_src

** Extract filter output

#+begin_src python


  def filter_output(out):
      res = []
      for line in out:
          if 'to-match' in line:
              res.append(line)

      return res

#+end_src

Or even better:

#+begin_src python

  def filter_output(out):
      return filter(lambda l: 'to-match' in l, out)

#+end_src


** And finally


#+begin_src python
  def write_filtered_ls_to_db():
      """Do a bit of everything
      """
      out = run_ls()
      res = filter_output(out)
      update_to_database(res)
#+end_src

** Now test it!

#+begin_src python

  def filter_output(out):
      return filter(lambda l: 'to-match' in l, out)

  def test_filter_output():
      lines = ['x1: to-match', 'x2', 'x3: to-match..']
      desired = ['x1: to-match', 'x3: to-match..']
      assert filter_output(lines) == desired

#+end_src

* Resources

  - Okasaki for persistent data structures
  - All Rich Hickey talks

* Haskell

  - pure
  - lazy
  - pattern matching
  - algebraic data types
  - type inference

[[./images/haskell.png]]

** Fibonacci

#+begin_src haskell
  fib :: Int -> Int
  fib 0 = 0
  fib 1 = 1
  fib n = fib (n-1) + fib (n-2)
#+end_src

Or better:

#+begin_src haskell
  fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
#+end_src

#+RESULTS:

** Quicksort

#+begin_src haskell
  quicksort :: (Ord a) => [a] -> [a]  
  quicksort [] = []  
  quicksort (x:xs) =   
      let smallerSorted = quicksort [a | a <- xs, a <= x]  
          biggerSorted = quicksort [a | a <- xs, a > x]   

      in  smallerSorted ++ [x] ++ biggerSorted
#+end_src

* Quotes
  - "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures." â€”Alan Perlis

# Local Variables:
# after-save-hook: (org-reveal-export-to-html)
# End:
